"use strict";(self.webpackChunkapp_try=self.webpackChunkapp_try||[]).push([[8710],{89414:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>r,contentTitle:()=>c,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"frontend/Vitest/spies-vitest","title":"Spying on Functions in Vitest","description":"Learn how to use spies in Vitest to monitor and track function calls, verify arguments, and mock implementations.","source":"@site/docs/frontend/2. Vitest/spies-vitest.mdx","sourceDirName":"frontend/2. Vitest","slug":"/frontend/spying-on-function-in-vitest","permalink":"/docusphere/docs/frontend/spying-on-function-in-vitest","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Spying on Functions in Vitest","description":"Learn how to use spies in Vitest to monitor and track function calls, verify arguments, and mock implementations.","slug":"/frontend/spying-on-function-in-vitest","authors":["tanishq"]},"sidebar":"frontend","previous":{"title":"Vitest Expect Matchers","permalink":"/docusphere/docs/frontend/vitest/expect-matcher"},"next":{"title":"General Overview","permalink":"/docusphere/docs/frontend/react-testing-library"}}');var s=t(74848),o=t(28453);const a={title:"Spying on Functions in Vitest",description:"Learn how to use spies in Vitest to monitor and track function calls, verify arguments, and mock implementations.",slug:"/frontend/spying-on-function-in-vitest",authors:["tanishq"]},c=void 0,r={},l=[{value:"Using Spies in Vitest",id:"using-spies-in-vitest",level:2},{value:"1. Basic Spy Example",id:"1-basic-spy-example",level:3},{value:"2. Spying on Class Methods",id:"2-spying-on-class-methods",level:3},{value:"3. Mocking Implementation with Spy",id:"3-mocking-implementation-with-spy",level:3},{value:"4. Spying on Module Functions",id:"4-spying-on-module-functions",level:3}];function p(n){const e={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.p,{children:"In Vitest, spies allow you to monitor and intercept function calls without modifying the original implementation. They are useful for:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Tracking the number of times a function is called."}),"\n",(0,s.jsx)(e.li,{children:"Verifying arguments passed to a function."}),"\n",(0,s.jsx)(e.li,{children:"Checking return values of a function."}),"\n",(0,s.jsx)(e.li,{children:"Restoring the original function after testing."}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["Vitest provides the ",(0,s.jsx)(e.code,{children:"vi.spyOn"})," method to create spies on object methods, making it easier to test interactions within your code."]}),"\n",(0,s.jsx)(e.h2,{id:"using-spies-in-vitest",children:"Using Spies in Vitest"}),"\n",(0,s.jsx)(e.h3,{id:"1-basic-spy-example",children:"1. Basic Spy Example"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"import { describe, it, expect, vi } from 'vitest';\n\nconst math = {\n  add: (a, b) => a + b,\n};\n\ndescribe('Spy Example', () => {\n  it('tracks calls to the add method', () => {\n    const spy = vi.spyOn(math, 'add');\n    \n    math.add(1, 2);\n    math.add(3, 4);\n    \n    expect(spy).toHaveBeenCalled();\n    expect(spy).toHaveBeenCalledTimes(2);\n    expect(spy).toHaveBeenCalledWith(1, 2);\n    expect(spy).toHaveBeenCalledWith(3, 4);\n    \n    spy.mockRestore();\n  });\n});\n"})}),"\n",(0,s.jsx)(e.h3,{id:"2-spying-on-class-methods",children:"2. Spying on Class Methods"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"class Calculator {\n  multiply(a, b) {\n    return a * b;\n  }\n}\n\ndescribe('Class Method Spy', () => {\n  it('tracks calls to the multiply method', () => {\n    const calculator = new Calculator();\n    const spy = vi.spyOn(calculator, 'multiply');\n    \n    calculator.multiply(2, 3);\n    \n    expect(spy).toHaveBeenCalledWith(2, 3);\n    expect(spy).toHaveReturnedWith(6);\n    \n    spy.mockRestore();\n  });\n});\n"})}),"\n",(0,s.jsx)(e.h3,{id:"3-mocking-implementation-with-spy",children:"3. Mocking Implementation with Spy"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"describe('Mock Implementation', () => {\n  it('provides a mock implementation', () => {\n    const obj = {\n      greet: (name) => `Hello, ${name}!`,\n    };\n    \n    const spy = vi.spyOn(obj, 'greet').mockImplementation((name) => `Hi, ${name}!`);\n    \n    expect(obj.greet('Alice')).toBe('Hi, Alice!');\n    \n    spy.mockRestore();\n  });\n});\n"})}),"\n",(0,s.jsx)(e.h3,{id:"4-spying-on-module-functions",children:"4. Spying on Module Functions"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"// utils.js\nexport function sum(a, b) {\n  return a + b;\n}\n\n// utils.test.js\nimport { sum } from './utils';\nimport { vi } from 'vitest';\n\ndescribe('Module Function Spy', () => {\n  it('tracks calls to the sum function', () => {\n    const spy = vi.spyOn({ sum }, 'sum');\n    \n    sum(1, 2);\n    \n    expect(spy).toHaveBeenCalledWith(1, 2);\n    \n    spy.mockRestore();\n  });\n});\n"})})]})}function d(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(p,{...n})}):p(n)}},28453:(n,e,t)=>{t.d(e,{R:()=>a,x:()=>c});var i=t(96540);const s={},o=i.createContext(s);function a(n){const e=i.useContext(o);return i.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function c(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:a(n.components),i.createElement(o.Provider,{value:e},n.children)}}}]);